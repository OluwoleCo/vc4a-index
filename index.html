<!DOCTYPE html>
<head>
    <title>VC4A Index (Beta)</title>
    <link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="img/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
    <link rel='stylesheet' id='vc4a-index-css'  href='dist/css/style.css' type='text/css' media='all' />
</head>
<meta charset="utf-8">
<body>
<!-- start -->
<div id="map">
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/4.0.0/d3.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3-queue/3.0.7/d3-queue.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3-annotation/2.3.0/d3-annotation.min.js"></script>
    <script src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <script>

    // Set defaults 
    var focused = false,
        ortho = true, 
        sens = 0.25;
    var margin = {top: 10, left: 10, bottom: 10, right: 10},
        width = parseInt(d3.select('#map').style('width')),
        width = width - margin.left - margin.right,
        mapRatio = 0.9,
        height = width * mapRatio;
    active = d3.select(null);

    // Create map projection 
    var projection = d3.geoOrthographic()
        .scale(width/2)
        .rotate([-15, 0])
        .translate([width / 2, height / 3])
        .clipAngle(90);

    var path = d3.geoPath()
        .projection(projection);

    var svg = d3.select("#map").append("svg")
        .attr("width", width)
        .attr("height", height);

    var infoLabel = d3.select("#map").append("div").attr("class", "infoLabel");

    var g = svg.append("g")
        .style("stroke-width", "1.5px");

    // Queue external map data
    d3.queue()
        .defer(d3.json, "data/world-110m.v1.json")
        .defer(d3.tsv, "data/world-110m.v1.tsv")
        .await(ready)

    d3.select(window).on("resize", resize);

    function resize() {
        // Adjust map when the window size changes
        width = parseInt(d3.select('#map').style('width'));
        width = width - margin.left - margin.right;
        height = width * mapRatio;

        // Update projection
        projection
            .scale([width/2])
            .translate([width /2, height / 3]);
      
        // Resize map container
        d3.select("#map").attr("width",width).attr("height",height);
        d3.select("svg").attr("width",width).attr("height",height);  
        d3.selectAll("path").attr('d', path);
    }

    function ready(error, world, countryData) {
        if (error) throw error;
        
        var countryById = {},
        countries = topojson.feature(world, world.objects.countries).features;

        // Add countries by name
        countryData.forEach(function(d) {
            countryById[d.iso_n3] = d.name;
        });

        // Add oceans
        g.append("path")
            .datum({type: "Sphere"})
            .attr("class", "water")
            .attr("d", path);

        // Draw countries on the globe
        var world = g.selectAll("path")
            .data(countries)
            .enter().append("path")
            .attr("overflow", "hidden")
            .attr("class", "mapData")
            .attr("d", path)
            .classed("ortho", ortho = true)

        // Event handlers 
        world.on("mouseover", function(d) {

        })
        .on("mouseout", function(d) {

        })
        .on("resize", resize)
        .on("click", function(d) {        
            if (focused === d) return reset();
            g.selectAll(".focused").classed("focused", false);
            d3.select(this).classed("focused", focused = d);

            country = countryById[d.id]
            console.log(d);

            infoLabel.text(country)
            .style("display", "inline");
            
            // Clicked on feature
            var p = d3.geoCentroid(d);
            console.log(countryById[d.id]);
            
            // Store the current rotation and scale
            var currentRotate = projection.rotate();
            var currentScale = projection.scale();
            
            // Calculate the future bounding box after applying a rotation
            projection.rotate([-p[0], -p[1]]);
            path.projection(projection);
            
            // calculate the scale and translate required
            var b = path.bounds(d);
            var nextScale = currentScale * 1 / Math.max((b[1][0] - b[0][0]) / (width/2), (b[1][1] - b[0][1]) / (height/2));
            var nextRotate = projection.rotate();

            // Update the map
            d3.selectAll("path")
             .transition()
             .attrTween("d", function(d) {
                  var r = d3.interpolate(currentRotate, nextRotate);
                  var s = d3.interpolate(currentScale, nextScale);
                      return function(t) {
                          projection
                              .rotate(r(t))
                              .scale(s(t));
                          path.projection(projection);
                          return path(d);
                      }
             })
             .duration(1000);

            // Set defaults 
            var stage = "Start-up";
            var stageDesc = "(All)";
            var limit = 5000;
            var status = "r_fundraising";
            var statusDesc = "Fundraising";

             // Fetch data from API
            $.ajax({
                dataType: "json",
                url: "https://api.vc4a.com/v1/fundraising/search.json",
                type: "GET",
                data: { 
                    "status": status, 
                    "country": country, 
                    //"stage": stage,
                    "limit": limit
                },
                success: function (data) {
                    var total = 0;
                    var venturesCount = 0;
                    $.each(data, function() {
                        $.each(this, function() {
                          if (typeof this.capital !== 'undefined') { 
                              for(var i=0;i<this.capital.length;i++) {
                                  //if (typeof this.capital[i].stage !== 'undefined' && this.capital[i].stage == stageDesc) {
                                  if (typeof this.capital[i].stage !== 'undefined') {
                                      total += Number(this.capital[i].amount); 
                                      venturesCount++;                                   
                                      //console.log( this.id + ' ' + this.capital[i].amount + ' total:' + total  );
                                  }
                              }
                          }
                        });
                    });

                    // Prepare output 
                    var totalCap = total.toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,');
                    var infoBox = document.getElementsByClassName('infoLabel');
                    var capOutput = document.createElement('p');
                    var capText = '<b>' + venturesCount + '</b> ventures currently ' + statusDesc + '<br />';
                        capText += 'Finance Round: ' + stageDesc + ' / Sectors (All)<br />';
                    capOutput.innerHTML = capText + ' Total Capital: <b>USD $' + totalCap + '</b>';
                    infoBox.item(0).appendChild(capOutput);

                    
                },
                error: function (xhr, ajaxOptions, thrownError) {
                    console.log(xhr.status);
                    console.log(thrownError);
                }
            });
        });

        // Drag event - simpler without? 
        world.call(d3.drag()
            .subject(function() { var r = projection.rotate(); return {x: r[0] / sens, y: -r[1] / sens}; })
            .on("drag", function() {
                var λ = d3.event.x * sens,
                φ = -d3.event.y * sens,
                rotate = projection.rotate();

                //Set limits for rotation
                φ = φ > 20 ? 20 :
                φ < -20 ? -20 :
                φ;
                // λ = λ > 10 ? 10 :
                // λ < -10 ? -10 :
                // λ;
                projection.rotate([λ, φ]);
                g.selectAll("path.ortho").attr("d", path);
                g.selectAll(".focused").classed("focused", focused = false);
            })
        )

        // Add extra data when focused
        function focus(d) {
            if (focused === d) return reset();
            g.selectAll(".focused").classed("focused", false);
            d3.select(this).classed("focused", focused = d);
        }

        function reset() {
            active.classed("focused", false);
            active = d3.select(null);
            
            g.selectAll(".focused").classed("focused", focused = false);
            infoLabel.style("display", "none");

            d3.selectAll("path")
                .transition()
                .attrTween("d", function(d) {
                var r = d3.interpolate(projection.rotate(), [-15, 0]);
                var s = d3.interpolate(projection.scale(), width/2);
                    return function(t) {
                        projection
                            .scale(s(t))
                            .rotate(r(t));
                        path.projection(projection);
                        return path(d);
                    }
               })
              .duration(1500);
        }

    };


    </script>
</div>
<!-- end -->
</body>
</html>